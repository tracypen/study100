### Redis 过期策略

> 缓存的删除策略一般有三种： 定时删除、定期删除、惰性删除

- 定时删除：设置过期时间后，开启一个定时任务，指定时间后进行删除
- 定期删除：每隔一段时间筛选过期的缓存进行删除
- 惰性删除：不主动删除缓存，当下次访问该缓存是，先判断是否已经过期，如果过期就立即删除，同时返回空的数据

Redis 过期策略是：**定期删除+惰性删除**

- 首先**定时删除**肯定不适合，想象一下数据量大的情况下，开启大量的定时任务，造成的系统资源占用。
- 其次，这里定期删除也不会删除所有的过期的key，redis的是随机删除已经过期的数据中的部分数据，因为全部删除性能消耗太大
- 如果只用惰性删除的话会导致，对于那些过期后长时间不访问甚至不再访问的数据，将一直占用系统内存，造成空间大量浪费

综上：所以Redis使用**定期删除**和**惰性删除**策略进行过期数据管理

但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？

答案是：**走内存淘汰机制**。

### 内存淘汰机制

redis 内存淘汰机制有以下几个：

- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用，不靠谱。
- **allkeys-lru**：当内存不足以容纳新写入数据时，在**键空间**中，移除最近最少使用的 key（这个是**最常用**的）。
- allkeys-random：当内存不足以容纳新写入数据时，在**键空间**中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
- volatile-lru：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，移除最近最少使用的 key（这个一般不太合适）。
- volatile-random：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key。
- volatile-ttl：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。

##### 经典面试题：

- Redis中key过期后会立即删除吗？

